X_grp[as.numeric("7"),]
View(X_grp)
rm(pos)
X_grp[as.numeric("7"),'grp']
X_grp[as.numeric(ppv),'grp']
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
#Fonction qui trouve le voisin le plus proche (distance euclidienne)
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
###Fonction qui calcule notre stat de Test
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#distances[pos,which(distances[pos,]==pp[pos])]
X_grp[as.numeric(ppv),'grp']
X_grp[as.numeric(ppv),'grp']==X_grp[,'grp']
sum(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
sum(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])/dim(X_grp)[1]
sum(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])/dim(X_grp)[1]
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- sum(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])/dim(X_grp)[1]
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- mean(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- mean(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
rm(statT)
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- mean(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
sample(X_grp)
sample(X_grp, replace = F)
sample(X_grp, replace = F)
sample(X_grp, replace = F)
sample(X_grp, replace = F)
sample(X_grp, replace = F)
?sample
test <- X_grp[sample(1:length(X_grp)),]
sample(1:length(X_grp))
test <- X_grp[sample(1:dim(X_grp)[1]),]
View(test)
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
#distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- sum(as.numeric(ppv[1:100]<=100))
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
#distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- sum(as.numeric(ppv[1:100])<=100)
as.numeric(ppv[1:100])
as.numeric(ppv[1:100])<=100
sum(as.numeric(ppv[1:100])<=100)
#Option pour que le code ne soit pas affiché lors du knit
knitr::opts_chunk$set(echo = FALSE)
#Chargement des données
load("examen-dataset/permutation-dataset.Rdata")
#Affichage du graphique
plot(X, col = c(rep('black',100),rep('red', 100)),pch=16, xlab='x1', ylab='x2')
#Ajout d'une colonne groupe à notre jeu de données
X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X_grp[,c('x1', 'x2')]))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT <- mean(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
X_grp[as.numeric(ppv),'grp']==X_grp[,'grp']
sum(X_grp[as.numeric(ppv),'grp']==X_grp[,'grp'])
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT2 <- mean(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100)
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT2 <- sum(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100)
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT2 <- mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100))
z <- X[sample(1:dim(X)[1]),]
View(z)
numeric(1000)
#Paramètres et vecteurs dont nous aurons besoin après
b <- 1000
test <- function(){
X_h0 <- X[sample(1:dim(X)[1], replace=F),]
distances <- as.matrix(dist(X_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
return(mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100)))
}
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
#Paramètres b du nombre de répétition
b <- 1000
statT <- numeric(b)
test <- function(){
X_h0 <- X[sample(1:dim(X)[1], replace=F),]
distances <- as.matrix(dist(X_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
return(mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100)))
}
sapply(statT,test)
rep(function())
rep(test())
rep(test(),20)
#Paramètres b du nombre de répétition
b <- 1000
statT <- numeric(b)
#Boucle allant de 1 à b
for (i in 1:b){
#Changement des positions des points au sein de X
X_h0 <- X[sample(1:dim(X)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(X_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
statT[i] <- mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100))
}
#Ajout de notre vrai T (observé sur les données) à la simulation
statT <- c(statT0,statT)
#Option pour que le code ne soit pas affiché lors du knit
knitr::opts_chunk$set(echo = FALSE)
#Chargement des données
load("examen-dataset/permutation-dataset.Rdata")
#Affichage du graphique
plot(X, col = c(rep('black',100),rep('red', 100)),pch=16, xlab='x1', ylab='x2')
#Ajout d'une colonne groupe à notre jeu de données
#X_grp <- cbind(c(rep(0, 100), rep(1, 100)), X)
#colnames(X_grp) <- c('grp', 'x1', 'x2')
###Calcul de notre stat de Test
#Fonction qui trouve le voisin le plus proche
FindPpv <- function(ind){
return(names(ind)[which(ind == min(ind, na.rm = TRUE))])
}
#Matrice des distances
distances <- as.matrix(dist(X))
diag(distances) <- NA
#Vecteur des voisins
ppv <- apply(distances,1,FindPpv)
#Calcul de la stat T
statT0 <- mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100))
#Paramètres b du nombre de répétition
b <- 1000
statT <- numeric(b)
#Boucle allant de 1 à b
for (i in 1:b){
#Changement des positions des points au sein de X
X_h0 <- X[sample(1:dim(X)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(X_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
statT[i] <- mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100))
}
#Ajout de notre vrai T (observé sur les données) à la simulation
statT <- c(statT0,statT)
hist statT
hist(statT)
hist(statT)
hist(statT)
hist(statT, xlab='T', main='Distribution de notre statistique T')
abline(v=statT0)
hist(statT, xlab='T', main='Distribution de notre statistique T')
abline(v=statT0, col='red')
quantile(statT)
?quantile
#Calcul de notre p-valeur
pval = mean(statT >= statT0)
statT
sort(statT)
statT >= statT0
#Calcul de notre p-valeur
pval = mean(statT[-1] >= statT0)
n <- seq(10,90,10)
?sample
n <- seq(10,90,10)
subX <- rbind(X[sample(1:dim(X)[1]/2, size=n[1], replace=F),], X[sample(dim(X)[1]/2+1:dim(X)[1], size=n[1], replace=F),])
sample(1:dim(X)[1]/2, size=n[1], replace=F),
sample(1:dim(X)[1]/2, size=n[1], replace=F),]
sample(1:dim(X)[1]/2, size=n[1], replace=F)
1:dim(X)[1]/2
1:int(dim(X)[1]/2)
1:integer(dim(X)[1]/2)
dim(X)[1]/2
1:100
int(dim(X)[1]/2)
integer(dim(X)[1]/2)
1:integer(dim(X)[1]/2)
1:as.integer(dim(X)[1]/2)
n <- seq(10,90,10)
subX <- rbind(X[sample(1:as.integer(dim(X)[1]/2), size=n[1], replace=F),], X[sample(as.integer(dim(X)[1]/2+1):dim(X)[1], size=n[1], replace=F),])
View(subX)
View(X)
n+1:2*n
n+1
n[1]:n[1]*2
ppv[1:n[1]]
ppv[n[1]+1:2*n[1]]
n[1]
n[1]+1
2*n[1]
11:20
c(n[1]+1:2*n[1])
c(n[1]+1:20)
c(n[1]+1:10)
n[1]+1:30
ppv[n[1]+1:30]
ppv[n[1]+1:2*n[1]]
ppv[n[1]+1:(2*n[1])]
ppv[(n[1]+1):(2*n[1])]
#Initialisation des paramètres
n <- seq(10,90,10)
statT <- numeric(b)
Pval_n <- function(n){
#Boucle allant de 1 à b
for (i in 1:b){
#Tirage aléatoire de n valeurs de x dans chaque population
subX <- rbind(X[sample(1:as.integer(dim(X)[1]/2), size=n, replace=F),], X[sample(as.integer(dim(X)[1]/2+1):dim(X)[1], size=n, replace=F),])
#Changement des positions des points au sein de subX
subX_h0 <- subX[sample(1:dim(subX)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(subX_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
statT[i] <- mean(c(as.numeric(ppv[1:n])<=n, as.numeric(ppv[(n+1):(2*n)])>n))
}
}
#Ajout de notre vrai T (observé sur les données) à la simulation
#statT <- c(statT0,statT)
Pval_n(10)
#Paramètres b du nombre de répétition
b <- 1000
statT <- numeric(b)
#Boucle allant de 1 à b
for (i in 1:b){
#Changement des positions des points au sein de X
X_h0 <- X[sample(1:dim(X)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(X_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
statT[i] <- mean(c(as.numeric(ppv[1:100])<=100, as.numeric(ppv[101:200])>100))
}
#Ajout de notre vrai T (observé sur les données) à la simulation
statT <- c(statT0,statT)
#Calcul de notre p-valeur
pval = mean(statT[-1] >= statT0)
#Affichage de l'histogramme de la distribution de nos T
hist(statT, xlab='T', main='Distribution de notre statistique T')
abline(v=statT0, col='red')
#Initialisation des paramètres
n <- seq(10,90,10)
statT <- numeric(b)
Pval_n <- function(n){
#Boucle allant de 1 à b
for (i in 1:b){
#Tirage aléatoire de n valeurs de x dans chaque population
subX <- rbind(X[sample(1:as.integer(dim(X)[1]/2), size=n, replace=F),], X[sample(as.integer(dim(X)[1]/2+1):dim(X)[1], size=n, replace=F),])
#Changement des positions des points au sein de subX
subX_h0 <- subX[sample(1:dim(subX)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(subX_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
return(mean(c(as.numeric(ppv[1:n])<=n, as.numeric(ppv[(n+1):(2*n)])>n)))
}
}
#Ajout de notre vrai T (observé sur les données) à la simulation
#statT <- c(statT0,statT)
Pval_n(10)
Pval_n(20)
Pval_n(30)
Pval_n(100)
#Initialisation des paramètres
n <- seq(10,90,10)
Pval_n <- function(n, t0, b){
#Initialisation de statT
statT <- numeric(b)
#Boucle allant de 1 à b
for (i in 1:b){
#Tirage aléatoire de n valeurs de x dans chaque population
subX <- rbind(X[sample(1:as.integer(dim(X)[1]/2), size=n, replace=F),], X[sample(as.integer(dim(X)[1]/2+1):dim(X)[1], size=n, replace=F),])
#Changement des positions des points au sein de subX
subX_h0 <- subX[sample(1:dim(subX)[1], replace=F),]
#Calcul de T
distances <- as.matrix(dist(subX_h0))
diag(distances) <- NA
ppv <- apply(distances,1,FindPpv)
statT[i]<-mean(c(as.numeric(ppv[1:n])<=n, as.numeric(ppv[(n+1):(2*n)])>n))
}
statT <- c(t0,statT)
return(mean(statT[-1] >= t0))
}
Pval_n(n=10, t0=statT0, b=1000)
Pval_n(n=20, t0=statT0, b=1000)
Pval_n(n=30, t0=statT0, b=1000)
Pval_n(n=40, t0=statT0, b=1000)
Pval_n(n=40, t0=stat50, b=1000)
Pval_n(n=50, t0=statT0, b=1000)
#Calcul de la p-valeur pour chaque n
sapply(n, Pval_n, t0=statT0, b=1000)
#Calcul de la p-valeur pour chaque n
pval_n <- sapply(n, Pval_n, t0=statT0, b=1000)
plot(x=n, y=pval_n,)
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de n')
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe')
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='p')
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='o')
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
rbind(pval_n,pval_n)
pval_n_10 <- sapply(n, Pval_n, t0=statT0, b=1000)
for(i in 1:9){
pval_n_10 <- rbind(pval_n_10, sapply(n, Pval_n, t0=statT0, b=1000))
}
View(pval_n_10)
plot(x=n, y=pval_n, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n_10, xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n_10[,1], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
lines(x=n, y=pval_n_10[2,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,1.2))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.12))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.11))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.10))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.1))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b')
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.1))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', col=i)
}
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.1))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', col=i)
}
abline(v=0.05, col='red')
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.1))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', col=i)
}
abline(h=0.05, col='red')
plot(x=n, y=pval_n_10[1,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', ylim=c(0,0.1))
for(i in 2:dim(pval_n_10)[1]){
lines(x=n, y=pval_n_10[i,], xlab='n', ylab='p-valeur', main='Evolution de la p-valeur en fonction de la taille de chaque groupe', type='b', col=i)
}
abline(h=0.05, col='red', lty=2)
